#!/usr/bin/php
<?
/*

Spartan(Minimalistic) PHP Unit Test Framework

2011-08-24 - V1.3

Author: Sergey Porfiriev <parf@comfi.com>
License: MIT (http://www.opensource.org/licenses/mit-license.php)

TODO:
: do not rewrite original files if not needed!!!
: add multiline support
: implement as a class   -- Why bother??

*/

if(php_sapi_name()!='cli')
    die("cli required");

ini_set('display_errors', 1);

$me=array_shift($argv); // get rid of $__0
if (! $argv)
    usage($me);

// Arguments
$ARG=array(); // ARGS
foreach($argv as $a)
    if ($a[0]=='-')
        $ARG[$a]=1;

if (@$ARG["--help"])
  return readfile(__DIR__.'/README.md');

if (@$ARG["--example"])
  return readfile(__DIR__.'/examples/sample.test');

if (@$ARG["--legal"])
  return legal();

// files from stdin support
if (@$ARG['--'] || @$ARG['--stdin'])
    $argv=file("php://stdin", FILE_IGNORE_NEW_LINES);

if (@$ARG["--clean"])
    $ARG["-g"]=1;

$__REGENERATE = @$ARG["-g"];
$__STDOUT     = @$ARG["-o"];
$__SILENT     = @$ARG["-s"] ||  @$ARG["-silent"];
if ($__STDOUT)
    $__SILENT=1;
if ($__SILENT)
    $ARG["--nocolor"]=1;

# console colors, only for xterm capable terminals
if (strpos(getenv("TERM"),'xterm')!==false)
    $ARG["--color"]=1;
if (@$ARG["--nocolor"])
    unset($ARG["--color"]);
$__NORM=$__BOLD=$__RED=$__BLUE="";
if (@$ARG["--color"]) {
    $__NORM="\033[0m";
    $__BOLD="\033[1m";
    $__RED="\033[31m";
    $__BLUE="\033[34m";
}

if (! @$ARG["--halt-on-errors"])
    set_error_handler('Error::handler');

$__fn    = 0; // file_number
while( $__file=array_shift($argv) ) {
    $__start = microtime();
    if ($__file[0]=='-')
        continue;

    $__fn++;
    if ($__fn==1) { // first file
        // search for "init.php" file and include it
        $path=realpath($__file);
        while( $path=dirname($path) ) {
            if ($path=="/")
                break;
            if ( file_exists($path."/init.php") ) {
                include $path."/init.php";
                break;
            }
        }
    }

    $__handle = @fopen($__file, "r");
    if (! $__handle ) {
        fwrite(STDERR, "Can't read file '$__file'\n");
        continue;
    }

    $__out=array(); // output
    $__r=false;
    $__z=false;
    $__c=0;     // 0 - code line,  1- result line
    $__new=0;
    $__l=0;     // # of lines processed
    $__tests=0; // # of tests
    $__failed=0;
    $__errs="";
    $__code="";
    $__ml_comment=0; // multiline comment flag

    while (!feof($__handle)) {
        $__l0=fgets($__handle);
        $__out[]=$__l0;
        $__line=trim($__l0);
        $__l++;
        $__l2=substr($__line, 0, 2);

        // multi-line comments
        if ($__l2=='/*') {
            $__ml_comment=1;
            continue;
        }
        if ($__ml_comment) {
            if (substr($__line,-2)=='*/')
                $__ml_comment=0;
            continue;
        }

        if ($__c && $__l2=='#=') {    // HAVE TO CHECK RESULTS
            if ($__REGENERATE) {
                array_pop($__out); // GET RID OF OLD RESULT.
                continue;
            }
            $__old=array_pop($__out);
            $__gen=array_pop($__out);
            $__out[]=$__old; // preserve old result

            $__r=substr($__line, 2);
            if ($__r==$__z)
                continue;

            $__errs.="Line $__l: $__BLUE$__code$__NORM\n  expect: $__r\n  got   : $__RED$__z$__NORM\n";
            $__failed++;
            continue;
        }

        if ($__l2=='#=') {
            $__errs="Line $__l: unexpected result comment: $__line removed\n";
            array_pop($__out);
            $__failed++;
            continue;
        }

        if (! $__line || $__l2=='//' || $__l2=='<?' || $__l2=='?>' || $__line[0]=='#')
            continue;
        // <? - vi coloring fix

        // ";command" - execute and discard result
        if($__l2[0]==';') {
            eval(substr($__line, 2));
            continue;
        }

        $__tests++;

        $__c=1;
        $__code=$__line;
        $__z="error";  // evaluation result
        ob_start();
        try {
            if ( substr($__line, 0, 5)=='echo ') {
                $__z='echo';
                eval($__line);
            } else
                eval("\$__z=$__line");
        } catch(Exception $__ex) {
            $__z=array(get_class($__ex), $__ex->getMessage(), $__ex->getCode());
        }
        if (is_object($__z))
            $__z=array("class" => get_class($__z), $__z);

        if ($__err=Error::get())
            $__z=array($__err[0] => $__err[1], "result" => $__z); // [error, result]

        $__ob=ob_get_clean();
        if ($__ob) {
            if ($__z==="error") {
                $__errs.="Line $__l: PHP Error: '$__line'\n  $__ob";
                $__failed++;
            } else
                $__z=array("r" => $__z, "out" => $__ob); // ["result" => .., "output" => ..]
        }

        $__z=json_encode($__z);
        $__out[]="#=".$__z."\n";
    }

    if (! $__REGENERATE) { // normal case
        $__t="*** Testing $__file - ";
        if ($__failed) {
            $__err=$__t."FAILED $__failed of $__tests tests\n";
            $__err=$__BOLD.$__RED.$__err.$__NORM;

            fwrite(STDERR, $__err);
        } else {
            if (! $__SILENT)
                echo $__t."OK $__tests tests in ".number_format(microtime()-$__start,2)."sec\n";
        }
        if ($__errs) {
            $__errs=str_replace("\n", "\n  ", $__errs); // identation
            fwrite(STDERR, "----------- Errors ---------\n  ".$__errs."\n");
        }
    } else {         // REGENERATE
        if (! $__SILENT)
            echo "*** $__file regenerated\n";
    }

    if ($__STDOUT) {
        echo join("", $__out);
        continue;
    }

    if (@$ARG["--clean"]) {
        echo "*** $__file cleaned\n";
        $r=array();
        foreach($__out as $o)
            if (substr(ltrim($o), 0, 2)!="#=")
                $r[]=$o;
        $__out=$r;
    }

    // update original file
    file_put_contents($__file, $__out);

    if (! $__SILENT)
        echo "\n";

} // while

return;

// --------------------------------------------------------------------------------

class Error {  // namespace
    static $err; // php-error from error handler

    // return error (if any), clean up error info
    static function get() {
        $e=self::$err;
        self::$err="";
        return $e;
    }

    static function handler ($level, $message, $file, $line, $context) {
        static $map=array(
                          E_NOTICE       => 'NOTICE',
                          E_WARNING      => 'WARNING',
                          E_USER_ERROR   => 'USER ERROR',
                          E_USER_WARNING => 'USER WARNING',
                          E_USER_NOTICE  => 'USER NOTICE',
                          E_STRICT       => 'E_STRICT',
                          );
        $type = ($t = @$map[$level]) ? $t : "ERROR#$level";
        self::$err = array($type, $message);
    }

}


// --------------------------------------------------------------------------------

function usage($me) {
    echo <<< USAGE
Spartan Test - minimalistic PHP unit test framework
Usage:
    $me --help
    $me --example
    $me --legal

    $me [-g] file.test [file2.test] ...
    ./file.test
    find . -name "*.test" | $me --

USAGE;
}

function legal() {
    echo "
AUTHOR
  Sergey Porfiriev <parf@comfi.com>

COPYRIGHT
  (C) 2010 Comfi.com

LICENSE
  The MIT License (MIT) - http://www.opensource.org/licenses/mit-license.php
";
}

?>
